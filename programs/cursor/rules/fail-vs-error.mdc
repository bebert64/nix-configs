---
description: Conventions for Fail enums vs error types
globs: "**/*.rs"
alwaysApply: false
---

# Fail vs Error

`Fail` enums represent **expected failures** caused by external factors (network, user input, third-party services), not bugs.
The project's error type (e.g. `DonError`, `InternalError`) and `anyhow::Error` represent **unexpected errors** that are most likely bugs or infrastructure issues.

## Key rules

- A `Fail` forces the caller to explicitly match on each variant and handle it. It must **not** be convertible to the outer error type via `?` — the compiler should force exhaustive handling.
- The typical signature is `Result<Result<T, Fail>, Error>` (outer Result carries real errors, inner Result carries domain-level failures).
- `Result<T, Fail>` without an outer error Result is rare and reserved for thin wrappers around the `Fail` itself.
- Do **not** implement `std::error::Error` or conversion traits on `Fail` types that would allow `?` to bypass the match.

## `try_or_wrap!` macro

Helper for working with `Result<Result<T, Fail>, Error>`:
- Unwraps the outer `Ok` and returns early on inner `Err` wrapped in `Ok`.
- Pattern: `match x { Ok(v) => v, Err(e) => return Ok(Err(e)) }` → `try_or_wrap!(x)`
